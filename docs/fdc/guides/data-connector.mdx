---
slug: data-connector
title: Flare Data Connector
authors: [lukaavbreht, filipkoprivec]
description: Learn how FDC obtains consensus on external data.
tags: [quickstart, bitcoin, fdc]
keywords: [quickstart, bitcoin, flare-data-connector, flare-network]
sidebar_position: 1
---

import MerkleProofExtractionOutput from "!!raw-loader!/examples/developer-hub-json/fdcMerkleProofExtractionOutput.json";
import PrepareRequestOutput from "!!raw-loader!/examples/developer-hub-json/fdcPrepareRequestOutput.json";
import PrepareResponseOutput from "!!raw-loader!/examples/developer-hub-json/fdcPrepareResponseOutput.json";
import IPaymentVerification from "!!raw-loader!/examples/developer-hub-solidity/FDCIPaymentVerification.sol";
import Payment from "!!raw-loader!/examples/developer-hub-solidity/FDCPayment.sol";
import PaymentAggregationExample from "!!raw-loader!/examples/developer-hub-solidity/FDCPaymentAggregationExample.sol";
import PaymentVerification from "!!raw-loader!/examples/developer-hub-solidity/FDCPaymentVerification.sol";
import CheckMerkleProof from "!!raw-loader!/examples/developer-hub-typescript/fdc_check_merkle_proof.ts";
import GetPreparedResponse from "!!raw-loader!/examples/developer-hub-typescript/fdc_get_prepared_response.ts";
import MerkleProofExtraction from "!!raw-loader!/examples/developer-hub-typescript/fdc_merkle_proof_extraction.ts";
import PrepareRequest from "!!raw-loader!/examples/developer-hub-typescript/fdc_prepare_request.ts";
import SubmitRequest from "!!raw-loader!/examples/developer-hub-typescript/fdc_submit_request.ts";
import CodeBlock from "@theme/CodeBlock";

Flare Data Connector provides a mechanism for the Flare network's providers to bring events within the wider blockchain ecosystem, and even beyond, onto Flare, thus enabling the smooth exchange of information and synchronization of smart contracts and state changes. In this guide, you will learn how to:

- Bridge data across blockchains and other sources using the Data Connector.
- Understand the working of the CCR protocol to securely verify and publish external data.
- Attest to a Bitcoin transaction and use the proof on Flare network.

This guide includes code snippets to recreate the process of attesting to a payment on the Bitcoin network and using the proof on the Flare Network. The complete setup and full code are available on the [Flare Demo examples](https://github.com/flare-foundation/flare-demo-examples) repository. You are encouraged to follow along and try it yourself. The repository contains all the necessary code and instructions to set up the environment and run the code.

:::info

If you are new to Flare, make sure you first understand the [Flare Network](/network/overview).

Starter packs for [Hardhat](https://github.com/flare-foundation/flare-hardhat-starter) and [Foundry](https://github.com/flare-foundation/flare-foundry-starter) are available to help you get started with Flare development.

:::

The Data Connector is a protocol on the Flare Network that enables any smart contract on the network to query non-changing, verifiable information from external sources, including (but not limitted to) other blockchains. It provides data in a decentralized and secure manner. This is achieved through a set of independent attestation providers that retrieve the required information from the source and deliver it to the Flare Network. The Data Connector smart contract then verifies if there is sufficient consensus among the received answers and publishes the results.

## Transferring external data to Flare

This guide focuses on the [**Payment attestation type**](https://github.com/flare-foundation/songbird-state-connector-protocol/blob/main/specs/attestations/active-types/Payment.md), an attestation type designed to prove and relay data about a transaction that happened on an external chain. You will write a simple script that allows a smart contract deployed on Songbird Testnet Coston to act upon a Bitcoin transaction without a centralized oracle.

For example, suppose you have a transaction on the Bitcoin (BTC) network and want to use this information on Flare, you can achieve this in the following steps:

1. **Verifying the transaction.** Submit the BTC transaction to a verifier (a service provided by attestation providers or another entity) of your choice. The verifier returns a JSON containing all the information about the transaction and a hex string representing an encoded attestation request to be submitted to the Data Connector smart contract.

2. **Making an attestation request.** Submit the hex-encoded request to the Data Connector smart contract, which emits an event to notify attestation providers about your request.

3. **CCR phases.** Wait for all stages of the overlapped Collect-Choose-Resolution (CCR) protocol to finalize. A detailed description of the stages of the CCR protocol can be found below.

4. **Merkle proof extraction.** Once the data is confirmed by the attestation providers and the Data Connector contract reaches a consensus on the final Merkle root, the transaction data can be used on the Flare blockchain. To use the data, you will need the response and Merkle proof, which can be queried from the attestation provider of your choice.

5. **Submitting Merkle proof.** Submit the response and Merkle proof to your smart contract. The smart contract verifies the proof using a dedicated verification contract that checks the response against the stored Merkle root using the Merkle proof. This verification is available both on the chain and in the Data Connector repository.

Let's understand each of these steps in detail in the following sections.

### 1. Verifying the transaction

Start by picking your favourite transaction on [Blockstream's Bitcoin Testnet explorer](https://blockstream.info/testnet/tx/recent).

- The transaction **should not** be older than two days.
- The transaction **should** be confirmed by at least 6 blocks.
- Note down the transaction hash.

:::note

Data Connector's confirmation requirements are different for each [connected blockchain](https://github.com/flare-foundation/songbird-state-connector-protocol/tree/main/specs/attestations/configs.md).

:::

Keep in mind that there is a strict separation between testing and production environments. The Data Connector is configured as follows:

- Songbird Canary-Network and Flare Mainnet: Connected to Bitcoin, Dogecoin, and XRP Ledger.
- Songbird Testnet Coston and Flare Testnet Coston2: Connected to Bitcoin Testnet, Dogecoin Testnet, and XRP Ledger Testnet.

What this means for the attestation client, is that a different base URL should be used (e.g., `coston.attester.xx` vs `songbird.attester.xx`). Additionally, you need to specify `testBTC` for the network name (`sourceId`) instead of `BTC`, because it is included in the transaction encoding.

Now that you have the transaction hash you want to prove, the next step is to construct the encoded version of the data you want to attest. While you can do this manually, the process is complex and requires access to an indexer.

A simpler approach is to use an API provided by verifier servers (verifiers). Their role is to verify the forwarded transaction data and format an attestation request following the verification rules of the corresponding attestation type. To be precise, you can forward the data about the chosen transaction to the verifier's API. The verifier then tries to fetch the transaction from the relevant blockchain node or indexer, and compile a response (consisting of an encoding of the request). If it is unsuccessful in either of these steps, the attestation request would be rejected by Data Connector and thus verification fails. The verifier returns the compiled response along with a signal of whether or not verification was successful. If the latter is true, the encoded request can be successfully submited for attestation. You can refer to the full verifier specification on the [Verifier server](https://github.com/flare-foundation/songbird-state-connector-protocol/tree/main/specs/attestations/verifier.md), while the attestation types are covered in [Part 2](attestation-types) of this guide.

To get the encoded request using default verifier implementations, call the `${ATTESTATION_URL}/verifier/btc/Payment/prepareRequest` endpoint. Here are the steps to follow:

<CodeBlock language="typescript" title="prepareRequest.ts">
  {PrepareRequest}
</CodeBlock>

This code requests verification for a specific source, `testBTC`, and attestation type, `Payment`. Both the type and source are hex-encoded strings, enabling easier extensibility.

The core part of the request is the `requestBody`. The body structure varies for each attestation type. For the `Payment` type, the `requestBody` includes the transaction hash, and both `inUtxo` and `utxo` parameters. These parameters provide detailed control over the sender and recipient addresses. The specifics of these parameters are defined by the [Payment type definition](https://github.com/flare-foundation/songbird-state-connector-protocol/blob/main/specs/attestations/active-types/Payment.md), which will be covered in a later section.

If the selected verifier successfully finds the transaction, the API will return a response like this:

<CodeBlock language="json">
  {PrepareRequestOutput}
</CodeBlock>

The `status` field indicates that the verifier recognized this transaction as valid (it was included in a block within the correct time range). The `abiEncodedRequest` contains all the data necessary for the attestation clients to include it in the final Merkle root.

This encoded request is what you'll submit to the Data Connector contract. Once submitted, it will be emitted as an event, picked up by attestation providers, verified, and used on the blockchain.

<details>
    <summary>Understanding the structure of `abiEncodedRequest`.</summary>

    The structure of `abiEncodedRequest` may seem complex, but it's essentially a concatenated hex string (with the initial 0x removed) representing different parts of the request. Each part is 32 bytes long (64 characters in hex). Here's a breakdown of the string:

    ```text
    5061796d656e7400000000000000000000000000000000000000000000000000
    7465737442544300000000000000000000000000000000000000000000000000
    10594158b4a189785feda815241c4e6f299053a65b22c3d748e9f0a6c34372e5
    01c17d143c03b459707f540fd5ee9f02a730c4cd114f310ef294b706ccf131d1
    0000000000000000000000000000000000000000000000000000000000000008
    0000000000000000000000000000000000000000000000000000000000000004
    ```

    You can decode the first two parts using an online tool like [playcode.io](https://playcode.io/1752890).

    Breaking it down line-by-line:

    - **First line:** `toHex("Payment")`

    - **Second line:** `toHex("testBTC")`

    - **Third line:** Message Integrity Code (MIC). This is a hash of the whole response salted with a string `Flare`. It ensures the integrity of the attestation and prevents tampering.

    - **Remaining lines:** These contain the request data, including the transaction hash, `inUtxo`, and `utxo` parameters.

</details>

### 2. Making an attestation request

The next step is to request attestation on the Data Connector smart contract, thus broadcasting to the entire network that you want this transaction to be proven. This will be your first interaction with the blockchain and will involve making a transaction. For this, you'll need a small amount of CFLR to cover gas fees. You can obtain testnet CFLR using the [CFLR faucet](https://faucet.flare.network/).

Once the attestation is requested you can calculate the `roundId` - the Data Connector's attestation round in which your request will be processed. You now have to wait for this round to end to be able to get the proof. This takes between 3 and 4.5 minutes.

<CodeBlock language="typescript" title="submitRequest.ts">
  {SubmitRequest}
</CodeBlock>

### 3. CCR phases

Flare's Data Connector protocol operates in **attestation rounds**, each consisting of three consecutive phases:

1. **Collect**: In this phase lasting 90 seconds, users send their requests to the Data Connector contract, which emits them as events. Attestation providers gather these requests, assign them to a voting round based on the emission timestamp, and attempt to compile a response.

2. **Choose**: In a process called bit voting, attestation providers vote on which of the requests gathered in the collect phase they can provide valid responses for; some requests may be invalid, or be of an attestation type not supported by the individual provider. To vote, each attestation provider submits a **bit vector** (hexadecimally encoded binary vector with *i*-th digit denoting the provider's ability to verify request *i* ) to the Data Connector contract. This phase begins immediately after the end of the collect phase and lasts 45 seconds.

3. **Resolution**: The resolution phase begins after the choose phase has finished, and lasts for 45 seconds. This phase can be understood in three parts, handled in turn.
   - Bit voting: To conclude the bit voting process started in the choose phase, each attestation provider runs a local deterministic algorithm to compute the consensus bit vector. The chosen algorithm aims to find the best subset of requests that can be jointly confirmed by the network.

   - Signing: Attestation providers create a Merkle tree with the leaves containing hashed responses to all the requests marked valid in the consensus bit-vector. Each provider then signs their Merkle root with the ECDSA key corresponding to their address, and publishes it on-chain along with the consensus bit-vector.
    <details>
      <summary>Merkle tree, Merkle root, and Merkle proof </summary>

      **Merkle tree** data structure enables efficient and secure verification of the contents of a large data set. It is a binary tree, with each leaf the hash of a data entry, and each other node the hashed concatenation of its children. The root of the Merkle tree, called the **Merkle root**, is therefore a single hash whose value depends on all the entries in the data set.
      
      In order to verify an entry is part of the data set summarized with the Merkle root, one needs to know the siblings of all ancestor nodes of the leaf corresponding to the data entry. This is called the **Merkle proof**. If our data entry is valid, the Merkle root can be reconstructed from the Merkle proof with the following iterative process:
        - Knowing the hash of the entry and its sibling leaf, the value of the parent node can be calculated.
        - Knowing the values of the parent node and its sibling, the value of the "grandparent" node can be obtained.
        - ...
    </details>

   - Finalization: The goal of finalization is to obtain a consensus response to the gathered requests. Attestation providers collect submitted signatures for matching Merkle roots, and can publish them (and the corresponding Merkle root) on-chain once the threshold weight of signatures is reached.

Both the **choose** and **resolution** phases last 45 seconds, totaling 90 seconds, and coincide with the **collect** phase of the subsequent attestation round.

As with all protocols on the Flare network, providers are incentivized to participate correctly in the Flare Data Connector. Incentives align with the goals of the FDC: they reward serving attestations for correct requests and establishing consensus in a timely manner.

### 4. Merkle proof extraction

Once the resolution phase is concluded, the attestation has been finalized, and consequently, a Merkle root has been stored within the Data Connector smart contract. As previously explained, this Merkle root serves as the apex of a Merkle tree, encompassing hashes of responses to attestation requests, including the one you aim to validate.

Our next step entails acquiring a Merkle proof—verification that the hash of our transaction indeed resides within the accepted Merkle tree, thereby confirming its acceptance by both the group of attestors and the Data Connector smart contract. The most straightforward approach is to leverage one of the attestation clients. If the attestation client has submitted the Merkle tree for the corresponding round, obtaining the proof from them involves a straightforward lookup within said tree. This process streamlines the verification, ensuring a swift and efficient confirmation of our transaction's acceptance.

Utilizing the `roundId` associated with the data submission from the preceding step, along with the `abiEncodedRequest` submitted earlier, make a call to the API endpoint:

```text
${ATTESTATION_URL}/attestation-client/api/proof/get-specific-proof
```

<CodeBlock language="javascript">
  {MerkleProofExtraction}
</CodeBlock>

The result of the call yields a JSON similar to the following.

<details>
    <summary>JSON result</summary>

    <CodeBlock language="json">
      {MerkleProofExtractionOutput}
    </CodeBlock>

</details>

The result comprises of multiple sections (all adhering to a uniform structure across different attestation types), namely, `request`, `response`, and `merkleProof`:

 - `request` includes comprehensive details about the request initiated in the previous step, enabling the receiving smart contract to verify the nature of the request made.

 - `response` includes details about the response to the `request`, enabling the user to verify several aspects of the transaction. For example, one may want to check whether the payment amount is sufficient, if the payment has been accepted, whether it was directed to the correct address, and more.

 - `merkleProof` section is utilized by the verification contract to ascertain the inclusion of this attestation within the Merkle tree for the specific round. It's worth noting that the proof, despite being short in size (logarithmic in comparison to the number of attestations requested in the round), is pivotal for validation.

 Each attestation type interface has a `.Proof` segment, which is designed so that incorporating the entirety of the attestation response, including the Merkle proof, is as simple as possible. In our example, where the request is of attestation type `Payment`, this data constitutes the interface segment `Payment.Proof`.

<details>
    <summary>Payment Solidity Interface</summary>

    <CodeBlock language="solidity" title="Payment.sol">
      {Payment}
    </CodeBlock>

</details>

You can read the full specification of the [Payment attestation type](https://github.com/flare-foundation/songbird-state-connector-protocol/tree/main/specs/attestations/active-types/Payment.md). Attestation types in general are covered in [Part 2](attestation-types) of this guide.

### 5. Submitting Merkle proof

Writing a trasaction on chain may alter blockchain state. Hence, any interaction of a smart contract with Flare Data Connector is a security-vulnerable operation and should incorporate the following aspects:

1. **Validation of Relay Information**: The contract needs to verify that the relayed information contains sufficient details to execute the intended action. For instance, it might need to confirm that the payment amount is adequate to mint an NFT. As discussed earlier, the necessary information for this validation is provided by the Data Connector.

2. **Verification of Relay Authenticity**: Once the relayed information is deemed sufficient, the contract must verify its authenticity by confirming that it was indeed relayed by the Data Connector and that the accompanying Merkle proof is valid. This verification is performed by submitting the Merkle proof to the verification contract. This contract, which will be explored further in the next section, acts as a wrapper around OpenZeppelin's Merkle proof verification contract. The verification process is typically initiated as soon as the resolution phase of the CCR protocol is concluded, thus being the first request to the Data Connector smart contract in the subsequent round. To ascertain whether the round in which the request was submitted has been finalized, one can check the `lastFinalizedRoundId` method on the Data Connector smart contract.

#### Verification contract

As mentioned earlier, each Data Connector verification contract (there should be one for each attestation type) is essentially a straightforward wrapper around OpenZeppelin's Merkle proof verification contract. While the code for these verification contracts can be found in the [verification subfolder](https://github.com/flare-foundation/songbird-state-connector-protocol/tree/main/contracts/generated/verification), they've been deployed on the Songbird Testnet Coston for ease of use and are already included in the Periphery Library Unofficial Contract Registry.

The verifier interface resembles the payment interface already discussed, with similar components and structures.

<CodeBlock language="solidity" title="IPaymentVerification.sol">
  {IPaymentVerification}
</CodeBlock>

The `verifyPayment` function accepts the `Payment.Proof` structure as its argument and returns a boolean value indicating whether the provided proof is correct.

Essentially, the contract serves as a wrapper that retrieves the Merkle root from the Data Connector contract and verifies the proof against it. This process ensures the authenticity and integrity of the relayed payment information.

<CodeBlock language="solidity" title="PaymentVerification.sol">
  {PaymentVerification}
</CodeBlock>

Note that verification can be ran **on-chain**, with the aim of submitting the Merkle proof to one's smart contract pending successful verification, or **off-chain**. The latter leaves no trace on the chain and incurs no cost. It is thus useful in testing.

We give steps you can follow in each setting below.

#### Off-chain verification

You can first check the proof off-chain (recall that verification is just a view method) and then create a simple contract that will store the verifications and verify them on-chain.

<CodeBlock language="typescript" title="checkMerkleProof.ts">
  {CheckMerkleProof}
</CodeBlock>

Running this you should result in:

```text
Verification tx: true
```

Hooray! This means that the verifier has accepted your Merkle proof and concluded the entire process.


#### On-chain verification

The on-chain verification process is equally straightforward. You simply ask the verifier, just as you did off-chain. Verification doesn't incur any costs to verify the proof on-chain, apart from minimal gas expenses.

<details>
    <summary>Solidity code to verify proof on-chain and keep track of total transaction values.</summary>

    <CodeBlock language="solidity" title="PaymentAggregationExample.sol">
      {PaymentAggregationExample}
    </CodeBlock>

</details>

Let's break down the key functions:

- `isPaymentValid`: This view function verifies if the provided payment is valid by checking if it's included in the Data Connector. We utilize the Flare-provided PaymentVerification contract in conjunction with the periphery library to directly access the verifier contract. The function is straightforward—we call the `verifyPayment` method on the verifier contract. Remember, this is a view function, so there are no costs associated with checking the proof on the chain.

- `addPayment`: This function is called by users to add payments to the contract. Remember, using the Data Connector on the chain typically involves a two-step process. Firstly, you validate the proof and data using the verifier contract, ensuring that the provided payment is valid. Then, you verify that the provided data meets our specific use case—such as being a payment in `testBTC`. Once you are certain of the payment's validity, you can tally the total received amount and store the proof for future reference.

## Conclusion

In the broader scope of a comprehensive application, this pipeline would integrate and execute whenever your decentralized application requires data from an external blockchain or the internet. By employing an innovative approach, utilizing independent attestation providers and the overlapped CCR protocol, the Data Connector ensures decentralized and secure access to data.

This guide has offered an in-depth exploration of attestation rounds, the Merkle tree structure, and practical implementation of the Data Connector for transaction verification on external chains. With its effective data bridging capabilities, the Data Connector is poised to redefine decentralized collaboration by enabling trustless interactions wiht diverse blockchain networks or the internet.

For those interested in exploring further, the entire codebase is available on [flare-demo-examples](https://github.com/flare-foundation/flare-demo-examples), where additional examples and helpful scripts are provided for running the setup independently. Feel free to dive in and explore!

<details>
    <summary>Obtain response data without proof.</summary>

    There are scenarios where you may simply need the response data without the accompanying proof or any Data Connector confirmation procedure details. This could be useful for debugging or verifying the data obtained from the Data Connector.

    To obtain only the response data, without the proof, you can query the prepareResponse endpoint with the same data as you would for prepareRequest. In doing so, you'll receive solely the response part. This enables you to verify locally whether the response is correct and aligns with what you intend to have proven.

    <CodeBlock language="typescript" title="getPreparedResponse.ts">
      {GetPreparedResponse}
    </CodeBlock>

    When you query the `prepareResponse` endpoint, you receive only the response part. You can then compare this response directly with the one you used in your contract interactions to ensure they match.

    <CodeBlock language="json">
      {PrepareResponseOutput}
    </CodeBlock>

</details>

<details>
    <summary>Automations for XRPL, Bitcoin and Dogecoin.</summary>

    Let's automate this process and create a script, that creates a transaction on external chain and immediately try to see what request you would get from the data connector.

    **XRP Ledger**

    In the `tryXRPLTransactionVerification.ts` file, a script initiates an XRPL transaction to a predefined address. Upon running the script after populating the `.env` file with an `XRPL_PRIVATE_KEY` containing testnet XRP ([Faucet](https://test.bithomp.com/faucet/)), the transaction is executed.

    Subsequently, you can immediately examine the request you would receive from the data connector. The script is straightforward, with the critical aspect being the proper encoding and padding of the standard payment reference to 32 bytes. If the standard payment reference adheres to the specification, it will also be included in the response from the Data Connector.

    An example result of this process:

    ```ts
    See transaction at https://testnet.xrpl.org/transactions/1D3FC0F8A2E509F2C4EC2F2F446075A60674C7C7EFE04948632444088FF54B42
    {
        "status": 'VALID',
        "response": {
            "attestationType": '0x5061796d656e7400000000000000000000000000000000000000000000000000',
            "sourceId": '0x7465737458525000000000000000000000000000000000000000000000000000',
            "votingRound": '0',
            "lowestUsedTimestamp": '1708820060',
            "requestBody": {
                "transactionId": '0x1D3FC0F8A2E509F2C4EC2F2F446075A60674C7C7EFE04948632444088FF54B42',
                "inUtxo": '0',
                "utxo": '0'
            },
            "responseBody": {
                "blockNumber": '45677518',
                "blockTimestamp": '1708820060',
                "sourceAddressHash": '0xa1ca3089c3e9f4c6e9ccf2bfb65bcf3e9d7544a092c79d642d5d34a54e0267e1',
                "receivingAddressHash": '0x0555194538763da400394fc7184432e9a006565fa710392ea1a86486eb83920f',
                "intendedReceivingAddressHash": '0x0555194538763da400394fc7184432e9a006565fa710392ea1a86486eb83920f',
                "standardPaymentReference": '0x48656C6C6F20776F726C64210000000000000000000000000000000000000000',
                "spentAmount": '22',
                "intendedSpentAmount": '22',
                "receivedAmount": '10',
                "intendedReceivedAmount": '10',
                "oneToOne": true,
                "status": '0'
            }
        }
    }
    Hello world!
    ```

    **Bitcoin (and Dogecoin)**

    The process is analogous: create a basic transaction with an `OP_RETURN` containing the payment reference. However, due to security considerations, you can't immediately verify the response as you do with XRPL transactions. Bitcoin requires 6 confirmations, and Dogecoin requires 60, typically taking just under an hour.

    As a result, the script solely generates the transaction and prints the transaction hash. Alternatively, it can use a provided transaction hash to query the response from the Data Connector.

    {/* <!--TODO:finish this code--> */}

</details>

## References

- Flare [Hardhat](https://github.com/flare-foundation/flare-hardhat-starter) and [Foundry](https://github.com/flare-foundation/flare-foundry-starter) starter packs.
- [Demo repository](https://github.com/flare-foundation/flare-demo-examples) for this guide.
- [Data Connector specification](https://git.aflabs.org/flare-external/state-connector-protocol-public/-/tree/main).
- Data Connector deployment on [Songbird Testnet Coston](https://coston-explorer.flare.network/address/0x0c13aDA1C7143Cf0a0795FFaB93eEBb6FAD6e4e3).
```
